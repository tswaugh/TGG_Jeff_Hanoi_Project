&ACCESS RVO
&REL 24
&PARAM TEMPLATE = C:\KRC\Roboter\Template\ExpertVorgabe
&PARAM EDITMASK = *
DEF SOLVE_HANOI()
;------- Declaration section --------
DECL INT FROM_TOWER, USING_TOWER, TO_TOWER, NEXT_INDEX
DECL AXIS HOME

;---------- Initialization ----------
; Set the Max velocities and accelerations
; set to 10 now for initial testing and setup
; once positions and logic are confirmed correct 100 should be safe
FOR I=1 TO 6
$VEL_AXIS[I]=10
$ACC_AXIS[I]=10
ENDFOR

; TODO: Modify $TOOL so that the center point is where we want tower center to be when picking up disks
$TOOL = $NULLFRAME
$BASE = $NULLFRAME

HOME={AXIS: A1 0, A2 -90, A3 90, A4 0, A5 0, A6 0}

FROM_TOWER = 1
USING_TOWER = 2
TO_TOWER = 3
NEXT_INDEX = 1

;----------- Main section ----------
PTP HOME ; BCO run - setup for movements

Dummy = MOVETOWER(HANOI_DISK_COUNT, FROM_TOWER, USING_TOWER, TO_TOWER, MOVE_ARRAY[,], NEXT_INDEX)

; Sanity check
IF NEXT_INDEX <> REQUIRED_MOVES + 1 THEN
HALT
ENDIF 

;Execute Movements
EXECUTE_SOLUTION(MOVE_ARRAY[,])

PTP HOME ; Back safe and sound.

END ;Main program END


; ------------EXECUTE_SOLUTION()------------
; EXECUTE_SOLUTION will execute the disk movements in MOVE_MATRIX
DEF EXECUTE_SOLUTION(MOVE_MATRIX[,])

DECL INT MOVE_MATRIX[,]
DECL INT DISK_COUNTS[3]
DECL INT CURR_FROM, CURR_TO
DECL REAL FROM_NEXT_DISK_Z, TO_NEXT_DISK_Z

DECL POS TOWER_BASES[3]
DECL POS TABLE, TOWER_ONE_BASE_REL, TOWER_TWO_BASE_REL, TOWER_THREE_BASE_REL, TRANSIT_OFFSET, PICK_UP_OFFSET, FROM_DISK_Z_OFFSET, TO_DISK_Z_OFFSET

DISK_COUNTS[1] = HANOI_DISK_COUNT
DISK_COUNTS[2] = 0
DISK_COUNTS[3] = 0

; Create the position vectors we'll use throughout executing the solution
TABLE = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TABLE.X = TABLE_X
TABLE.Y = TABLE_Y
TABLE.Z = TABLE_Z

; Tower bases are relative to the table base
TOWER_ONE_BASE_REL = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TOWER_ONE_BASE_REL.X = TOWER_ONE_X
TOWER_ONE_BASE_REL.Y = TOWER_ONE_Y
TOWER_ONE_BASE_REL.Z = TOWER_ONE_Z

TOWER_TWO_BASE_REL = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TOWER_TWO_BASE_REL.X = TOWER_TWO_X
TOWER_TWO_BASE_REL.Y = TOWER_TWO_Y
TOWER_TWO_BASE_REL.Z = TOWER_TWO_Z

TOWER_THREE_BASE_REL = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TOWER_THREE_BASE_REL.X = TOWER_THREE_X
TOWER_THREE_BASE_REL.Y = TOWER_THREE_Y
TOWER_THREE_BASE_REL.Z = TOWER_THREE_Z

; Pickup zone relative vector
PICK_UP_OFFSET = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
PICK_UP_OFFSET.X = PICK_UP_X_OFFSET

; Transit zone relative vector
TRANSIT_OFFSET = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TRANSIT_OFFSET.Z = TRANSIT_ZONE_Y_OFFSET

; Absolute tower positions
TOWER_BASES[1] = TABLE:TOWER_ONE_BASE_REL
TOWER_BASES[2] = TABLE:TOWER_TWO_BASE_REL
TOWER_BASES[3] = TABLE:TOWER_THREE_BASE_REL

; ------MAIN EXEC LOOP------
; Execute solution
FOR I = 1 to REQUIRED_MOVES
; Initialize current to and from tower
CURR_FROM = MOVE_MATRIX[I,1]
CURR_TO = MOVE_MATRIX[I,2]

FROM_NEXT_DISK_Z = DISK_COUNTS[CURR_FROM] * DISK_THICKNESS - DISK_PICKUP_OFFSET
TO_NEXT_DISK_Z = DISK_COUNTS[CURR_TO] * DISK_THICKNESS - DISK_PICKUP_OFFSET

FROM_DISK_Z_OFFSET = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
FROM_DISK_Z_OFFSET.Z = FROM_NEXT_DISK_Z
TO_DISK_Z_OFFSET = {POS: X 0, Y 0, Z 0, A 0, B 0, C 0}
TO_DISK_Z_OFFSET.Z = TO_NEXT_DISK_Z

; Check if from tower has  >= 1 disks on it and that to tower has positive number of disks (SANITY CHECK)
IF DISK_COUNTS[CURR_FROM] < 1 THEN
HALT
ENDIF

IF DISK_COUNTS[CURR_TO]  < 0 THEN
HALT
ENDIF

CURR_FROM_BASE = TOWER_BASES[CURR_FROM]
CURR_TO_BASE = TOWER_BASES[CURR_TO]

; TODO: Execute 6 steps to move disk and prep for next cycle
; Move to the pickup zone and align with next disk to pickup
PTP CURR_FROM_BASE:PICK_UP_OFFSET

;Move to tower center offset up by currdisk offset
PTP CURR_FROM_BASE:FROM_DISK_Z_OFFSET

; Move up to transit zone
PTP CURR_FROM_BASE:TRANSIT_OFFSET

; Align with to tower in transit zone
PTP CURR_TO_BASE:TRANSIT_OFFSET

; Lower to tower base + disk offset
PTP CURR_TO_BASE:TO_DISK_Z_OFFSET

; Retract into pickup zone
PTP CURR_TO_BASE:PICK_UP_OFFSET

; TODO: Change disk counts for from and to towers
DISK_COUNTS[CURR_TO] = DISK_COUNTS[CURR_TO] + 1
DISK_COUNTS[CURR_FROM] = DISK_COUNTS[CURR_FROM] - 1
ENDFOR

END ;Execute solution end

DEFFCT INT MOVETOWER(DNUM:IN, FROM_TOWER:IN, USING_TOWER:IN, TO_TOWER:IN, MOVE_MATRIX[,]:OUT, NEXT_INDEX:OUT)
; Not entirely sure if we need these declarations
DECL INT DNUM , FROM_TOWER , USING_TOWER , TO_TOWER , NEXT_INDEX
; Define MOVE_MATRIX again. It must be done.
DECL INT MOVE_MATRIX[,]

; Recursion base case
IF DNUM == 0 THEN

RETURN(1)

ELSE

; Temporarily move everything on top of the FROM_TOWER except the last disk to the USING_TOWER
Dummy = MOVETOWER(DNUM - 1 , FROM_TOWER , TO_TOWER , USING_TOWER , MOVE_MATRIX[,] , NEXT_INDEX)

; Move the bottom disk to the TO_TOWER
MOVE_MATRIX[NEXT_INDEX,1] = FROM_TOWER
MOVE_MATRIX[NEXT_INDEX,2] = TO_TOWER
NEXT_INDEX = NEXT_INDEX + 1

; Move the temporary stack from step 1 to the TO_TOWER
Dummy = MOVETOWER(DNUM - 1 , USING_TOWER , FROM_TOWER , TO_TOWER , MOVE_MATRIX[,] , NEXT_INDEX)

ENDIF

RETURN(1)

ENDFCT ;Movetower end